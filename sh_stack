#include <stdio.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <semaphore.h>
#include <stdlib.h>
#include <ctype.h>
#include <assert.h>
#include <signal.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <time.h>


struct stack_t
{
    int id_key;
    int size;
    sem_t *count;
    void** sh_stack;
};

/* Attach (create if needed) shared memory stack to the process.
Returns stack_t* in case of success. Returns NULL on failure. */
struct stack_t* attach_stack(key_t key, int size)
{
    struct stack_t* stack = malloc(sizeof(stack_t));
    stack->count = sem_open("count", O_RDWR | O_CREAT, 0666, 0);
    stack->id_key = shmget(key, size, 0666 | IPC_CREAT);
    stack->sh_stack = (void**)shmat(stack->id_key, NULL, 0);
    if (stack->id_key <= 0 || stack->sh_stack <= 0)
        return NULL;
    stack->size = size;
    return stack; 
}
/* Detaches existing stack from process. 
Operations on detached stack are not permitted since stack pointer becomes invalid. */
int detach_stack(struct stack_t* stack)
{
    shmdt(stack->sh_stack);
    free(stack);
    return 0;
}
/* Marks stack to be destroed. Destruction are done after all detaches */ 
int mark_destruct(struct stack_t* stack)
{
    printf("d id_key is %d\n", stack->id_key);    
    shmdt(stack->sh_stack);
    printf("delete %d\n", shmctl(stack->id_key, IPC_RMID, 0));
    sem_unlink("count");
    free(stack);
    return 0;
}
/* Returns stack maximum size. */
int get_size(struct stack_t* stack)
{
    return stack->size;
}
/* Returns current stack size. */
int get_count(struct stack_t* stack)
{
    int* ret;
    sem_getvalue(stack->count, ret);
    return ret[0];
}
/* Push val into stack. */
int push(struct stack_t* stack, void* val)
{
    int* ret;
    sem_getvalue(stack->count, ret);
    if (ret[0] == (stack->size-1))
        return -1;
    stack->sh_stack[ret[0]] = val;
    sem_post(stack->count);
    return 0;
}   
/* Pop val from stack into memory */
int pop(struct stack_t* stack, void** val)
{
    int* ret;
    sem_getvalue(stack->count, ret);
    if (ret[0] == 0)
        return -1;
    val[0] = stack->sh_stack[ret[0]-1];
    sem_wait(stack->count);
    return 0;
}

int print_all(struct stack_t* stack)
{
    int i = 0;
    int* ret;
    sem_getvalue(stack->count, ret);
    printf("size is %d, count is %d, ", stack->size, ret[0]);
    printf("stack is { ");
    for (i = 0; i < ret[0]; i++)
    {
        printf("%p, ", stack->sh_stack[i]);
    }
    printf("}\n");
    return 0;
}
int main()
{
    char pathname1[] = "main.c", pathname2[] = "hand.c", pathname3[] = "-hand";
    key_t key1 = ftok(pathname1, 0);
    struct stack_t* st = attach_stack(key1, 100);
    int* test1 = malloc(4);
    test1[0] = 33;
    char* test2 = (char*)malloc(6);
    test2 = "comeon";
    push(st, (void*)test2);
    //push(st, (void*)test1);
    //push(st, (void*)test1);
    //push(st, (void*)test1);
    //push(st, (void*)test1);
    push(st, (void*)test2);

    void** val = malloc(7);

    print_all(st);
    void** t = malloc(4);
    //pop(st, t);
    int* q = t[0];
    //print_all(st);
    //printf("%d\n", q[0]);
    pop(st, val);
    print_all(st);
    printf("%s\n", (char*)val[0]);
    mark_destruct(st);
    //print_all(st);
}
